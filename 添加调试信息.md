# 添加调试信息 #

> 作者：蒋颖   王子昂

## 一、介绍 ##

源代码级调试使用格式化数据，帮助调试器从二进制文件和机器状态转换回程序员编写的源代码。在LLVM中，我们使用DWARF的格式。 

> DWARF：一种紧凑的编码，表示类型，源位置和变量位置。

修改语言的运行以及程序的编译方式：

* 拥有源文件，其中包含用VSL编写的简单程序
* 我们一次只能使用一个“top level”命令，以减少更改次数

## 二、静态提前（AOT）编译模式 ##

### 将包含顶级语句的匿名函数作为main函数 ###

```c++
// 只需要给它一个名字
auto Proto = llvm::make_unique<PrototypeAST>("main", std::vector<std::string>());
```

### 删除命令行代码 ###

删除`fprintf(stderr, "ready> ");`

```c++
int main() {
  InitializeNativeTarget();
  InitializeNativeTargetAsmPrinter();
  InitializeNativeTargetAsmParser();

  // Install standard binary operators.
  // 1 is lowest precedence.
  BinopPrecedence['='] = 2;
  BinopPrecedence['<'] = 10;
  BinopPrecedence['+'] = 20;
  BinopPrecedence['-'] = 20;
  BinopPrecedence['*'] = 40; // highest.

  // Prime the first token.
  getNextToken();

  TheJIT = llvm::make_unique<KaleidoscopeJIT>();

  InitializeModuleAndPassManager();

  // Run the main "interpreter loop" now.
  MainLoop();

  return 0;
}
```

### 禁用所有优化传递和JIT ###

在完成解析和生成代码之后将LLVM IR转到标准错误输出`stderr`

```c++
static void HandleTopLevelExpression() {
  // Evaluate a top-level expression into an anonymous function.
  if (auto FnAST = ParseTopLevelExpr()) {
    if (!FnAST->codegen()) {
        fprintf(stderr, "Error generating code for top level expr");
     }
  } else {
    // Skip token for error recovery.
    getNextToken();
  }
}
```

通过以下命令来运行程序：

```
Kaleidoscope-Ch9 < fib.ks | & clang -x ir -
```

在当前工作目录下会出现`a.out`或`a.exe`

## 三、编译单元 ##

DWARF中一段代码的顶级容器是一个编译单元。 它包含单个翻译单元的类型和函数数据。

## 四、DWARF生成准备 ##

`DIBuilder`类：帮助构建LLVM IR文件的调试元数据，使用此类来构建所有IR级别描述。

创建一个小容器来缓存一些频繁使用的数据

```c++
// 全局静态变量
static DIBuilder *DBuilder;

struct DebugInfo {
  // 编译单元
  DICompileUnit *TheCU;
  // 类型，我们只有一种数据类型
  DIType *DblTy;

  DIType *getDoubleTy();
} KSDbgInfo;

DIType *DebugInfo::getDoubleTy() {
  if (DblTy)
    return DblTy;

  DblTy = DBuilder->createBasicType("double", 64, dwarf::DW_ATE_float);
  return DblTy;
}
```

在`main`中建立模块：

```c++
DBuilder = new DIBuilder(*TheModule);

KSDbgInfo.TheCU = DBuilder->createCompileUnit(
    //在这里我们写死了文件名，实际使用中应该让用户输入文件名，然后我们在这里获取
    dwarf::DW_LANG_C, DBuilder->createFile("fib.ks", "."),
    "Kaleidoscope Compiler", 0, "", 0);
```

在`main`结束时，在卸载该模块前执行此操作

```c++
DBuilder->finalize();
```

## 五、函数 ##

### 向调试信息中添加函数定义 ###

在`PrototypeAST::codegen()` 中添加：

```c++
DIFile *Unit = DBuilder->createFile(KSDbgInfo.TheCU.getFilename(),
                                    KSDbgInfo.TheCU.getDirectory());
```

### 构造函数定义 ###

```c++
DIScope *FContext = Unit;
unsigned LineNo = 0;
unsigned ScopeLine = 0;
DISubprogram *SP = DBuilder->createFunction(
    FContext, P.getName(), StringRef(), Unit, LineNo,
    CreateFunctionType(TheFunction->arg_size(), Unit),
    false /* internal linkage */, true /* definition */, ScopeLine,
    DINode::FlagPrototyped, false);
TheFunction->setSubprogram(SP);
```

* `LineNo`,`ScopeLine`为0，因为此时AST还没有这些信息
* `DISubprogram`包含对该函数的所有元数据的引用。