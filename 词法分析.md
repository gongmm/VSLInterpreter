# 解释器构造

## CH 01 Lexer

### Kaleidoscope基础语言

* 过程性语言

* 唯一的数据类型是64位浮点类型（相当于double）


```c
 #计算 fibonacci 数
   if x < 3 then
     1
   else
     fib(x-1)+fib(x-2)

#This expression will compute the 40th number.
 fib(40)
```



*  调用标准库函数，可以使用extern关键字来定义函数

```c
 extern sin(arg);
 extern cos(arg);
 extern atan2(arg1 arg2);

 atan2(sin(.4), cos(42))
```

### The Lexer

> “[lexer](http://en.wikipedia.org/wiki/Lexical_analysis)” (又叫 ‘scanner’) 将输入分解为 “tokens”. 每个被 lexer返回的 token 包含一个 token code 和一些可能的 metadata (e.g. 数字的数值)。
>

```c
//The lexer returns tokens [0-255] if it is an unknown character, otherwise one
 // of these for known things.
 enum Token {
   tok_eof = -1,

   // commands
   tok_def = -2,
   tok_extern = -3,

   // primary
   tok_identifier = -4,
   tok_number = -5,
 };

 static std::string IdentifierStr; // Filled in if tok_identifier
 static double NumVal;             // Filled in if tok_number
```

  Lexer返回的 token 将是Token枚举值之一，或是一个'未知'字符，如'+'，它将作为ASCII值返回。

* 如果当前标记是标识符，则全局变量 IdentifierStr保存标识符的名称。

* 如果当前标记是数字（如1.0），则NumVal保持其值。

#### 步骤

1. 定义可能值的枚举，每个值代表token类型的一种情况：

   

```c
   enum Token{ 
     tok_eof = -1, //到达文件尾
     tok_def = -2, //token为关键字”def”
     tok_extern = -3, //token为关键字”extern”
     tok_identifier = -4, //token为标识符
     tok_number = -5, //token为数字
 }; 
 // 若是tok_identifier则填入该变量 
 static std::string IdenifierStr; //存储标识符的名字
 // 若是tok_number则填入该变量 
 static double NumVal;//存储数值的值
```



2. gettok函数，用于处理标准输入，读取下一个token，返回token（输入的语句的分词）的类型

```c
      static int gettok(){
     static int LastChar = ' ';

     //跳过空格
     while(isspace(LastChar))
         LastChar = getchar();
     // 识别标识符
     if(isalpha(LastChar)){
         IdentifierStr += LastChar;
         while(isalnum(LastChar = getchar()))
             IdentifierStr += LastChar;
         if(IdentifierStr == "def")
             return tok_def;
         if(IdentifierStr == "extern")
             return tok_extern;
         return tok_identifier;
     }
     // 识别数字
     if(isdigit(LastChar) || LastChar == '.'){
         std::string Numstr;
         do{
             NumStr += LastChar;
             LastChar = getchar();
         }while(isdigit(LastChar)||LastChar == '.');
         NumVal = strtod(NumStr.c_str(),0); //strtod()将string转换为数字（缺错误检查）
         return tok_number;
     }
     // 识别注释
     if(LastChar == '#'){
         // 跳过一整行
         do
             LastChar = getchar();
         while(LastChar != EOF && LastChar != '\n' && LastChar != '\r');

         if(LastChar != EOF)
               return gettok();
     }
     // 检查是否到了文件尾
     if(LastChar == EOF)
         return tok_eof;

     // 处理特殊情况，若以上情况都不是，则返回字符本身的ascii值
     int ThisChar = LastChar;
     LastChar = getchar();
     return ThisChar;
 }
```

### VSL词法分析

#### 词法

```
	comment		"//".*
	delimiter	[ \t\n]
	whitespace	{delimiter}+
	uc_letter	[A-Z]
	lc_letter	[a-z]
	letter		{lc_letter}|{uc_letter}
	ascii_char	[^\"\n]
	escaped_char	\\n|\\\"
	digit		[0-9]
	variable	{lc_letter}({lc_letter}|{digit})*
	integer		{digit}+
	text		\"({ascii_char}|{escaped_char})*\"

	%%

	{comment}	; { }
	{whitespace}	; { }
	{variable}	{ return VARIABLE; }
	{integer}	{ return INTEGER;}
	{text}		{ return TEXT;}
	":="		{ return ASSIGN_SYMBOL;}
	FUNC		{ return FUNC;}
	PRINT 		{ return PRINT;}
	RETURN 		{ return RETURN;}
	CONTINUE	{ return CONTINUE;}
	IF 		{ return IF;}
	THEN 		{ return THEN;}
	ELSE		{ return ELSE;}
	FI 		{ return FI;}
	WHILE 		{ return WHILE;}
	DO 		{ return DO;}
	DONE 		{ return DONE;}
	VAR 		{ return VAR;}
	.		{ return yytext[0]; }

```





