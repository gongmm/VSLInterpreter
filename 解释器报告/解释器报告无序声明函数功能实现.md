## 支持乱序声明函数

我们的VSL语言向java一样支持以随意的顺序声明及定义函数，并可相互调用。

实现逻辑为，若CallExprAST再调用某个函数时，没有找到该函数，那么就根据调用语句中调用的未定义的函数名和变量个数，先声明一个函数原型，放在名为MainLackOfProtos的图中，暂时替代缺损函数。等到遇到缺损函数的声明时，再将函数的定义补全。

其中，获得某特定函数的方法getFunction定义如下，我们定义了两个图来存放函数原型，FunctionProtos存放已定义的函数的函数原型，MainLackOfProtos存放定义缺损的函数的函数原型。其中Module存放了已在内存中生成代码的函数的地址（即曾经测i调用过的函数）：

```c++
Function *getFunction(std::string Name) {
	// First, see if the function has already been added to the current module.
	if (auto *F = TheModule->getFunction(Name))
		return F;

	// If not, check whether we can codegen the declaration from some existing
	// prototype.
	auto FI = FunctionProtos.find(Name);
	if (FI != FunctionProtos.end())
		return FI->second->codegen();

	// If no existing prototype exists, return null.
	return nullptr;
}
```

为了实现乱序声明函数，我们定义了一个名为MainLackOfProtos的图用于存放缺损定义的函数的原型的图。

```c++
std::map<std::string, std::unique_ptr<PrototypeAST>> MainLackOfProtos;

Value *CallExprAST::codegen() {
    KSDbgInfo.emitLocation(this);
    //Callee为函数名称
	Function *CalleeF = getFunction(Callee);//从图中获得该函数
	if (CalleeF == nullptr) {//若当前定义了的函数中没有该函数，则先新建一个相同原型的空函数放入MainLackOfProtos图中暂存
		std::vector<std::string> ArgNames;
        //暂时将参数名设置为temp
		for (int i = 0; i < Args.size();i++) {
			ArgNames.push_back("temp"+i);
		}
        //将该替代的原型放入MainLackOfProtos图中
		MainLackOfProtos[Callee]= llvm::make_unique<PrototypeAST>(Callee, std::move(ArgNames));
		
		CalleeF = getLackFunction(Callee);
	}
	if (!CalleeF)
		return LogErrorV("Unknown function referenced");

	// If argument mismatch error.
	if (CalleeF->arg_size() != Args.size())
		return LogErrorV("Incorrect # arguments passed");

	std::vector<Value *> ArgsV;
	for (unsigned i = 0, e = Args.size(); i != e; ++i) {
		ArgsV.push_back(Args[i]->codegen());
		if (!ArgsV.back())
			return nullptr;
	}
//生成调用函数的语句
	return Builder.CreateCall(CalleeF, ArgsV, "calltmp");
}

```

而当我们发现了一个与缺损函数图中函数重名的函数定义时，将该函数定义与图中函数原型连接，并将该缺损函数原型移出MainLackOfProtos，放入Module中，以下代码为在FunctionAST::codegen() 中的实现。

```c++
auto &P = *Proto;

	Function *TheFunction;
	std::unique_ptr<PrototypeAST>temp;
	temp = std::move(MainLackOfProtos[Proto->getName()]);
//若该函数定义在MainLackOfProtos中有同名原型
	if (temp != nullptr) {
		auto args = temp->getArgs();
		auto Args = P.getArgs();
        //若缺损函数的参数个数与该函数定义不一致
		if (args.size() != Args.size()) {
			//args inconsistency
			return LogErrorF("main function's arg_size is inconsistent");
		}
		temp->setArgs(Args);
        //将缺损函数定义移入FunctionProtos中，再将它从MainLackOfProtos中移除
		FunctionProtos[Proto->getName()] = std::move(temp);
		MainLackOfProtos.erase(Proto->getName());
		TheFunction = getFunction(P.getName());
		if (!TheFunction)
			return nullptr;
		unsigned Idx = 0;
        //重新设置参数名称
		for (auto &Arg : TheFunction->args())
			Arg.setName(Args[Idx++]);
	}
......
```

